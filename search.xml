<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rose的安装]]></title>
    <url>%2F2019%2F05%2F27%2FRose%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Rose工具的安装Rose 2007是一款专业的可视化建模工具，用于可视化建模和公司级水平软件应用的组件构造。Rational Rose包括了统一建模语言（UML），OOSE，以及OMT。Rational Rose 2007有两个受欢迎的特征就是它的提供反复式发展和来回旅程工程的能力。 安装包及安装过程https://blog.csdn.net/xfz0330/article/details/39890867 安装包链接：https://pan.baidu.com/s/1DQtwbmoz1txt8w4RrKANVQ 提取码：h7fr]]></content>
      <categories>
        <category>工具 - Rose</category>
      </categories>
      <tags>
        <tag>Rose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的安装]]></title>
    <url>%2F2019%2F05%2F27%2Fhexo%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[hexo安装及配置[Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。]https://www.cnblogs.com/visugar/p/6821777.html https://blog.csdn.net/sinat_37781304/article/details/82729029 https://blog.csdn.net/weixin_39345384/article/details/80785373 hexo主题(next)https://theme-next.iissnan.com/getting-started.html 常用指令：1234hexo new &quot;文章标题&quot; //新建文章hexo clean &amp;&amp; hexo g //清空缓存并生成静态文件hexo s -p 4000 或者 hexo s //启动本地服务默认hexo d 或者 gulp deploy //部署发布 我的博客地址https://yulang.xyz/]]></content>
      <categories>
        <category>工具 - hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器是如何渲染网页的]]></title>
    <url>%2F2019%2F05%2F24%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5%E7%9A%84%2F</url>
    <content type="text"><![CDATA[现在我们主要接触的主流浏览器有：IE, FireFox, Safari, Chrome,Opera;你真的了解它们吗？ 1. 浏览器的主要功能 向服务器发出请求，在浏览器窗口中展示你选择的网络资源;（一般指HTML文档，也可以是PDF,图片，或其他的类型）资源的位置由用户使用的URL(统一资源标示符)指定。浏览器解释并显示HTML文件的方式是在HTML和CSS规范中指定的。这些规范由网络标准化组织W3C(万维网联盟)进行规定。2. 浏览器的主要组件 用户界面：(包括地址栏，前进/后退按钮，书签菜单等)。除了浏览器主窗口显示的各个部分都属于用户界面 浏览器引擎：在用户界面和呈现引擎之间传送指令 呈现引擎/渲染引擎/浏览器内核/排版引擎/解释引擎：负责显示请求的内容，并将解析后的内容显示在浏览器屏幕上 网络：用于网络调用，比如HTTP请求，其接口与平台无关，并为所有平台提供底层实现。 用户界面的后端：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript解释器：用于解析和执行JavaScript代码 123456主流浏览器 js引擎IE -&gt; Edge JScript（IE3.0-IE8.0） / ChakraChrome V8（大名鼎鼎）Safari Nitro（4-）Firefox SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）Opera Linear A（4.0-6.1）/ Linear B（7.0-9.2） 数据存储：(持久层)；浏览器需要在硬盘上保存各种数据，例如Cookie。HTML5定义了”网络数据库“（完整且轻便的浏览器内数据库） 3. 渲染引擎/浏览器内核解析 默认情况下，呈现引擎可显示HTML和XML文档与图片，通过插件(或浏览器扩展程序)显示，eg:PDF查看器插件就可以显示PDF文档。 不同的浏览器浏览器内核不相同123456主流浏览器 内核IE -&gt; Edge trident-&gt;EdgeHTMLChrome webkit-&gt;blinkSafari webkitFirefox GeckoOpera Presto-&gt;blink 4.浏览器渲染基本流程1234从网络层获取请求文档的内容（内容的大小一般限制在8000个块以内）---&gt;解析HTML构造DOM树和CSSOM树---&gt;构建渲染树(把DOM树中的一些不可视元素去掉，然后与CSSOM合成一棵render树）---&gt;渲染DOM树布局(计算出各个节点(元素)在屏幕的位置)--&gt;渲染树绘制(浏览器根据渲染树将页面渲染到屏幕) (1). 解析HTML文档一边边构建DOM树一边构建CSS规则树(CSSOM) 解析HTML/XHTML文档时，将各标记逐个转化成”内容树”上的DOM节点，遇到css标签或JS脚本标签就下载和解析（其中css是异步下载同步执行）； 在构建DOM树过程中，当遇到css元素{包括外部CSS样式以及内联样式}，浏览器会开启一个异步请求线程，在该线程上，浏览器会去请求相应的css文件，并且根据该文件去构建CSSOM树(也叫css rule)，css的加载并不会导致html解析和渲染的停止，即不会阻塞dom树的构建；该线程会阻塞 JavaScript引擎线程（即css后 面的js模块的解析会在css解析完毕后执行），因为js脚本不仅可以读取修改到dom，也可以读取修改到cssom。故在js脚本执前，browser必须保证到css文件完全加载并解析完成，即cssom树完全构建好。这就导致了js执行的延迟，也因此导致html解析和渲染延迟。（这就是css阻塞js执行，阻塞渲染的根本原因） 构建DOM树过程中，浏览器渲染和 JS 执行是共用一个线程，即单线程工作，多线程会产生渲染 DOM 冲突。如果遇到当遇到JS元素时，HTML解析器就会将控制权转让给JavaScript引擎线程，该线程会阻断HTML解析器的运行，就阻塞了DOM树的构建当js加载并且执行完毕后，JavaScript引擎线程会将控制权还给HTML解析器，让其去继续构建dom树。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性 JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，再恢复DOM树构建。这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 CSS规则树中的元素是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入规则树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在规则树中（但是 visibility 属性值为“hidden”的元素仍会显示）。有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。 eg:DOM树 eg:CSSOM树 (2). 浏览器引擎通过 DOM 树和CSS规则树(CSSOM)生成一颗渲染树(Rendering Tree) 渲染树是由DOM树和CSSOM树合成的；渲染树的每一个节点都有自己的style样式；渲染树上没有隐藏的节点，比如display：block和无样式head节点，就不会在渲染树上，因为这些节点不会呈现也不影响呈现；visibility:hidden会存在渲染树，因为它占有空间，会影响布局）(3). 渲染DOM树布局(reFlow 或 Layout)通过 CSS 规则树 匹配 DOM 树每个节点分配一个应出现在屏幕上的确切坐标，即进行定位坐标和大小(4). 绘制(paint)[调用操作系统Native GUI的API绘制]呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。 5.面试常问 浏览器渲染原理解析/浏览器渲染过程/浏览器怎么加载页面的？浏览器如果渲染过程中遇到CSS文件/JS文件怎么处理？/dom树和css树是如何合并的？/浏览器的运行机制是什么/什么会造成渲染阻塞？如何优化参考文章 https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/?from=timeline http://obkoro1.com/web_accumulate/accumulate/tool/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92.html#%E9%87%8D%E6%8E%92%E5%BD%B1%E5%93%8D%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%9A https://github.com/ljianshu/Blog/issues/51 https://blog.csdn.net/lxsjh/article/details/79158820浏览器运行机制参考文章 https://blog.csdn.net/yunqishequ1/article/details/79013330 https://www.cnblogs.com/caiyy/p/10406934.html https://segmentfault.com/a/1190000012925872#articleHeader20 https://www.jianshu.com/p/05606b0b4eb1 2019-05-05 18:42:17 星期日]]></content>
      <categories>
        <category>学习 - 浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async与defer的作用与区别以及阻塞优化]]></title>
    <url>%2F2019%2F05%2F23%2Fasync%E4%B8%8Edefer%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E9%98%BB%E5%A1%9E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[async和defer的作用是什么？有什么区别?1. 在浏览器在渲染时，在html文件中读取，会立即停止渲染，执行JS代码，如果没有 defer属性 或 async属性，会等script文件下载执行完后才继续渲染。2. &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;(异步下载)会下载脚本，但是不会立即执行，并且不一定按照script顺序触发；这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async可能在 DOMContentLoaded 触发之前或之后执行，但一定会在 load 触发之前执行。 (1)HTML5属性；Chorme,FireFox,IE9+浏览器支持 (2)async属性仅适用于外部脚本 (3)执行顺序是不确定的 (4)async 属性表示异步执行引入的 JavaScript (5)与 defer 的区别在于，如果已经加载好，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后 3. &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;(延迟执行)是否对脚本执行延迟，直到页面加载为止(1). 兼容所有浏览器(2). defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到HTML标签解析完成之后；(3). 如果脚本不改变文档的内容，可以用defer属性，以便加快处理文档速度(4).defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时HTML 并未停止解析，这两个过程是并行的(5).defer 不会改变 script 中代码的执行顺序，整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的JavaScript 代码，然后触发 DOMContentLoaded 事件。(6)所有设置了defer属性的脚本按顺序执行,async是无顺序的加载(7)无论设置了defer或async,该script会在onload前执行；(8)IE/chrome在设置defer时，与firefox不同，前者会等脚本执行后才执行DOMContentLoaded;而后者会先于脚本执行 script脚本阻塞有什么解决方法？(script异步加载的四种方式) （1）引入jquery1234$(document).ready(function()&#123;内容&#125;) （2）async属性（3）defer属性(4)动态创建标签—&gt;兼容所有浏览器1234567(function()&#123; var script =document.createElement('script'); script.type='text/javascript'; script.src="http://code.jquery.com/jquery-1.7.2.min.js"; var tmp=document.getElementsByTagName('script')[0],tem.parentNode.insertBefore(script,tmp);&#125;) - css阻塞有什么解决方法？css的加载并不会导致html解析和渲染的停止，但是会影响到js脚本的执行。因为js脚本不仅可以读取修改到dom，也可以读取修改到cssom。故在js脚本执前，browser必须保证到css文件完全加载并解析完成，即cssom树完全构建好。这就导致了js执行的延迟，也因此导致html解析和渲染延迟。（这就是css阻塞js执行，阻塞渲染的根本原因）因此一些解决方法： 1、在引入顺序上，css资源的引入要优于js脚本的引入 2、对css进行精简并尽快提供 3、可以用媒体类型（会加载不会阻塞） 4、用媒体查询（会记载，只有在符合的设备上才会进行阻塞） 参考文章： https://segmentfault.com/q/1010000000640869]]></content>
      <categories>
        <category>学习 - 浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的结构]]></title>
    <url>%2F2019%2F05%2F19%2FHTTP%E7%9A%84%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[HTTP结构图 HTTP结构之请求篇 (1)组成http请求报文由三部分组成，分别是：请求行(请求头)、消息报头、请求正文。 请求头（请求行）以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。请求方法如下： 请求正文(实体主体)：一般不用(2)请求报文的例子12345GET /chn/yxsz/index.htm HTTP/1.1 /*请求行使用相对URL*/ Host:www.tsinghua.edu.cn /*此行为首部行的开始，给出主机的域名*/ Connection:close /*告诉服务器发送完请求的文档可释放连接*/ user-Agent:Mozilla/5.0 /*表明用户代理是使用Netscape浏览器*/ Accept-Language:cn /*表示用户希望优先得到中文版本的文档*/ (3)HTTP请求过程（从URL输入到页面展现发生什么？）a.域名解析(浏览器通过向 DNS 服务器发送域名，DNS 服务器查询(查询缓存)到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器) 查找浏览器缓存（DNS缓存） 查找操作系统缓存（如果浏览器缓存没有，浏览器会从hosts文件查找是否有DNS信息） 查找路由缓存 查找ISP缓存 查找ISP缓存ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推） b.发起TCP的3次握手（浏览器获得对应的ip地址后，浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。） c.建立TCP连接后发送HTTP请求报文 d.服务器处理请求，并返回HTTP响应报文 e.浏览器解析,渲染,并绘制到网页 根据 HTML 解析出 DOM 树 根据 CSS 解析生成 CSS 规则树 结合 DOM 树和 CSS 规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 f. 断开连接（TCP 四次挥手） HTTP结构之响应篇 (1)组成在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 状态行包括状态码，协议版本，状态码描述;(状态行格式如下：1HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述 a. 1XX（信息响应类，表示接受的请求正在处理） b. 2XX（处理成功类，表示请求已被成功接收、理解、接受） 200 OK //客户端请求成功 ，请求被成功处理，服务器会根据不同的请求方法返回结果：GET：请求的对应资源会作为响应返回。 HEAD：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body) POST：返回处理对应请求的结果。 204 No Content //该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。206 Partial Content //该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。客户端发起的请求，必须在请求头中包含Range字段。服务端响应报文中，必须包含由Content-Range指定范围的实体内容(entity-bodies )c. 3XX（重定向响应类，表示需要客户端需要进行附加操作） 301 Moved Permanently // 永久重定向 该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：HEAD：必须在响应头部Location字段中指明新的永久性的URI。 GET：除了有Location字段以外，还需要在响应体中附上永久性URI的超链接文本。 POST：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。 302 Found // 临时重定向，该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问 和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。303 See Other //临时重定向，该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请 求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。304 Not Modified //资源找到但是不符合请求条件 该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部。307 Temporary Redirect //临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)d. 4XX（客户端错误，请求有语法错误或请求无法实现） 400 Bad Request //错误请求 客表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。401 Unauthorized //请求未授权 该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含WWW-Authenticate以指明服务器需要哪种方式的认证。403 Forbidden //拒绝 该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应404 Not Found //未找到 该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。405 //方法禁用 禁用请求中指定的方法e. 5XX（服务端错误，服务器处理请求出错） 500 Internal Server Error //服务器内部错误 该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。501 //尚未实施 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 //错误网关 服务器作为网关或代理，从上游服务器收到无效响应。503 Service Unavailable //服务不可用 状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入Retry-After首部字段再返回给客户端。504 //网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求 HTTP结构之消息报文（HTTP协议头）篇(1)组成HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 普通报头 在普通报文头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。常用的普通报头a. Cache-Control:用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。b. Date:普通报头域表示消息产生的日期和时间c. Connection:普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 请求报头 请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头a.AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的源；Accept：text/html，表明客户端希望接受html文本 b.Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 c.Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip,deflate如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 d.Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 e.AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 f.Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html;浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号 g.User-AgentUser-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。请求报头举例： 12345678910GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF)(CRLF) 响应报头 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。常用的响应报头a. LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。 b.ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=&quot;Basic Auth Test!&quot; //可以看出服务器对请求资源采用的是基本验证机制。 实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。常用的实体报头a. Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipb. Content-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:dac.Content-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。d. Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：12Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312 e. Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。 f. ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(&quot;Expires&quot;,&quot;0&quot;); 参考文章 https://blog.csdn.net/gueter/article/details/1524447 https://github.com/forthealllight/blog/issues/19 https://www.cnblogs.com/fundebug/p/what-happens-from-url-to-webpage.html http://www.cnblogs.com/xianyulaodi/p/6547807.html https://my.oschina.net/snowing1990/blog/707165]]></content>
      <categories>
        <category>学习 - 计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的发展历史]]></title>
    <url>%2F2019%2F05%2F17%2FHTTP%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[http版本导图 2. HTTP版本之概念篇 HTTP（超文本传输协议),是互联网上应用最为广泛的一种网络协议，定义了浏览器怎样向服务器请求文档，以及服务器怎样把文档传送给浏览器。HTTP基于TCP/IP协议的应用层协议，它不涉及数据包传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 HTTP/0.9版本篇要点 客户端向服务器请求网页，服务器只能回应HTML格式的字符串，不能回应别的格式。 只有GET方式 服务器发送完毕。就关闭TCP连接缺点 每个TCP连接只能发送一个请求;发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接 TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢 网页加载的外部资源越多，性能就越差 只有一种请求方式 HTTP/1.0版本篇要点 任何格式的内容都可以发送。互联网不仅可以传输文字，还可以传输图像，视频，二进制文件。（由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。CONTENT-ENCODING字段说明数据压缩的方法 1234压缩的方式有（可以并列多个，用逗号隔开）：CONTENT-ENCODING:GZIPCONTENT-ENCODING:COMPRESSCONTENT-ENCODING:DEATE 除了GET命令，还引入POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。 HTTP请求和回应格式发生改变，除了数据部分，每次通信都包括头部分，用来描述数据， 新增的功能还包括：状态码(STATUS CODE)，多字符集支持，多部分发送(MULTI-PART TYPE)，权限(ANTHORIZATION)，缓存(CACHE)，内容编码(CONTENT ENCODING)等1234567HTTP/1.0请求的例子：GET/HTTP/1.0 USER-AGENT:MOZILLA/5.0(MACINTOSH;INTEL MAC OS X 10_10_5 ) ACCEPT:*/*第一行为请求命令,必须在尾部添加协议版本(HTTP/1.0)后面为多行头信息，描述客户端情况 12345678910111213HTTP/1.0回应的例子：HTTP/1.0 200 OK /*协议版本+状态码+状态描述*/CONTENT-TYPE: TEXT/PLAIN CONTENT-LENGTH: 137582EXPIRES: THU, 05 DEC 1997 16:00:00 GMTLAST-MODIFIED: WED, 5 AUGUST 1996 15:55:28 GMTSERVER: APACHE 0.84&lt;HTML&gt; &lt;BODY&gt;HELLO WORLD&lt;/BODY&gt;&lt;/HTML&gt;CONTENT-TYPE:字符编码，HTTP 1.0规定 头部必须是ASCII码，后面可以是任何格式，因此，服务器回应时，CONTENT-TYPE的作用是：告诉客户端，数据是什么格式 缺点 非持续连接：每个TCP连接只能发送一个请求，每请求一个文档就需要两倍的RTT往返时间开销(一个RTT用于连接TCP连接，另一个用于请求和接收文档)。 如图所示：当HTTP协议首先要与服务器建立TCP连接，这就需要三次握手。当三次握手的前两部分完成后(即经过一个RTT时间后)，万维网客户就把HTTP请求报文作为第三次握手的第三个报文的数据发送给万维网服务器，服务器收到HTTP报文后，就把所请求的文档作为响应报文返回给客户。 发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。（为了解决这个问题：有些浏览器在请求时，用了一个非标准的CONNECTION字段。即CONNECTION:KEEP-ALIVE请求服务器不要关闭TCP连接，以便其他请求复用，服务器同样回复这个字段；以实现TCP的复用，直到客户端或服务器主动关闭连接，但，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 网页加载的外部资源越多，性能就越差。 5. HTTP/1.1版本篇 要点 引入了持久连接(PERSISITENT CONNECTION),即TCP连接默认不关闭，可以被多个请求复用，不用声明（简单的说：就是服务器在发送响应后仍热在一段时间内保持这条连接，使同一个用户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文）。CONNECTION:KEEP-ALIVE客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时明确要求服务器关闭TCP连接。CONNECTION:CLOSE 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。 引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。（提高HTTP协议的效率）；举例说明：客户端需要请求两个资源，HTTP1.0是在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发送B请求；管道机制是允许浏览器同时发生A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求 一个TCP连接可以传送多个回应，势必要有机制，区分数据包是属于哪一个回应的。这就是CONTENT-LENGTH字段的作用，声明本次回应的数据长度。 12CONTENT-LENGTH:3495告诉浏览器本次回应的长度是3495个字节，后面的字节就属于下一个回应 分块传输编码；HTTP1.1采用分块传输编码；使用CONTENT-LENGTH字段的前提是服务器发送回应之前，必须知道回应数据的长度。但对于一些耗时的动态操作来说，这意味着，服务器要等所有操作完成，才能发送数据，显然效率不高，更好的处理方式是：服务器每产生一块数据，就发送一块，采用“流模式（STREAM）”取代“缓存模式(BUFFER)”.因此1.1版规定可以不使用CONTENT-LENGTH字段，而使用“分块传输编码”，只要请求或回应的头信息有TRANSFER-ENCODING字段，就表明回应的数据将由数量未定的数据块组成。TRANSFER-ENCODING:CHUNKED每个非空的数据块之前，会有16进制的数值，表示这个块的长度，最后是一个大小为0的块，就表示本次回应的数据发送完。 12345678910111213141516Eg:HTTP/1.1 200 OKCONTENT-TYPE: TEXT/PLAINTRANSFER-ENCODING: CHUNKED25THIS IS THE DATA IN THE FIRST CHUNK1CAND THIS IS THE SECOND ONE3CON8SEQUENCE0 新增功能：PUT,PATCH,HEAD,OPTIONS,DELECT.客户端的头信息增加HOST字段，用来指定服务器的域名。HOST:WWW.EXAMPLE.COM有了HOST字段，就可以将请求发往同一台服务器的不同的网站，为虚拟主机的新起打下了基础。 缺点 虽然复用TCP连接，但是在同一个TCP连接里面，所有的数据通信都是按照次序进行的。服务器只有处理完一个回应，才能进行下一个回应。(解决办法：A. 减少HTTP请求数;B:同时多开持久连接) 6. HTTP/2版本篇 要点 采用二进制协议：HTTP/1.1的头信息是文本（ASCII编码），数据体可以是文本（解析非常麻烦），也可以是二进制。而HTTP/2则是一个彻底的二进制协议，头信息和数据体都是二进制，通称为“帧”（FRAME）:头信息帧和数据帧。二进制协议的一个好处是：可以定义额外的帧，解析方便。 多路复用(双向，实时的通信)：HTTP/2复用TCP连接，在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而不用按照顺序一一对应，这样就避免“队头阻塞”。举例来说：在一个TCP连接里面，服务器同时收到A请求和B请求，先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后，才发送B请求剩下的部分。 数据流：HTTP/2的数据流是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此必须要对数据包标记，指出它属于哪个回应。HTTP/2将每一个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流ID，用于区分它属于哪一个数据流，另外规定：客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送一半时，客户端和服务器都可以发送信号，取消这个数据流。即HTTP/2可以取消某一个请求，同时保证TCP连接还开着，可以被其他请求使用。客户端还可以指定数据流的优先级，优先级越高，服务器就越早回应。 头信息压缩：HTTP2以前的版本协议不带有状态，每次请求都必须附上所有的信息。所以，请求的很多字段都是重复的，比如COOKIE和USER AGENT,一模一样的内容，每次请求都必须附带，这很浪费很多宽带，也影响速度。HTTP/2优化了这一点。引入了头信息压缩机制。一方面：头信息使用GZIP或COMPRESS压缩后再发送，另一方面，客户端和服务端同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段，只发送索引号，提高速度。 服务器推送：HTTP/2允许服务器未经请求，主动向客户端发送资源–&gt;服务器推送。eg:客户端请求一个网页，这个网页里面包含静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发送静态资源请求；其实，服务器可以预期到客户端请求网页后，很可能再请求静态资源，所以主动把这些静态资源随网页一起发给客户端。 缺点 请求太多时也需要排队 7. HTTPS版本篇 要点 HTTPS 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL HTTPS协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性 HTTPS的SSL加密是在传输层实现的 工作原理 客户使用HTTPS URL访问服务器，则要求WEB 服务器建立SSL链接。 WEB服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。 客户端和WEB服务器端开始协商SSL链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 WEB服务器通过自己的私钥解密出会话密钥。 WEB服务器通过会话密钥加密与客户端之间的通信。优点 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。缺点 HTTPS握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。 HTTPS缓存不如HTTP高效，会增加数据开销。 SSL证书也需要钱，功能越强大的证书费用越高。 SSL证书需要绑定IP，不能再同一个IP上绑定多个域名，IPV4资源支持不了这种消耗。HTTP和HTTPS的区别 HTTPS协议需要证书，费用较高。 HTTP是超文本传输协议，传输的数据都是未加密的即明文传输，HTTPS则是具有安全性的SSL加密传输协议。 使用不同的链接方式，端口也不同，一般而言，HTTP协议的端口为80，HTTPS的端口为443 HTTP协议是无连接，无状态的；(无连接：虽然HTTP使用了TCP连接，但通信的双方在交换HTTP报文之前不需要建立HTTP连接;无状态：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系);HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。 HTTPS提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比HTTP1.0） HTTPS允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在HTTP1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。 二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码 HTTP2首部压缩;服务器端推送(相对于HTTP1.0) 7. SSL/TLS协议介绍互联网的通信安全是建立在SSL/TLS协议之上。不使用SSL/TLS的HTTP协议，就是不加密的通信；会带来三大风险： （1）窃听风险：第三方可以获取通信内容； （2）篡改风险：第三方可以修改通信内容。 （3）冒失风险：第三方可以冒充他人身份参与通信。SSL/TLS就是为了解决这三大风险而设计的，希望达到： （1）所有信息都是加密传播，第三方无法窃听 （2）具有校验机制，一旦被篡改，通信双方立即发现。 （3）配备身份证书，防止身份被冒充。SSL/TLS协议的基本思路采用公钥加密法，即客户端先向服务端索要公钥，然后用公钥加密信息，客户端收到密文后，用自己的私钥解密。 如何保证公钥不被篡改？解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 公钥加密计算量太大，如何减少耗用的时间？解决方法：每一次对话（SESSION），客户端和服务器端都生成一个”对话密钥”（SESSION KEY），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 SSL/TLS协议的基本过程： （1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成”对话密钥”。 （3） 双方采用”对话密钥”进行加密通信。上面过程的前两步，又称为”握手阶段”（HANDSHAKE）。开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手；HTTP耗时 = TCP握手；HTTPS耗时 = TCP握手 + SSL握手所以，HTTPS肯定比HTTP耗时，这就叫SSL延迟8. 参考文章 http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html http://www.ruanyifeng.com/blog/2016/08/http.html https://github.com/forthealllight/blog/issues/19 https://github.com/YanceyOfficial/interview/blob/master/HTTP/%5BHTTP%20%E7%B3%BB%E5%88%97%5D%20%E7%AC%AC%202%20%E7%AF%87%20%E2%80%94%E2%80%94%20HTTP%20%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B.md 2019-05-12 21:16:45 星期日]]></content>
      <categories>
        <category>学习 - 计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js:for ...of与 for... in]]></title>
    <url>%2F2019%2F05%2F15%2Ffor%20...of%E4%B8%8E%20for...%20in%2F</url>
    <content type="text"><![CDATA[for…in遍历对象的属性或数组索引（ES5） eg1:遍历数组12345var arr=['a','b','c','d']; for(let index in arr)&#123; console.log(index);// 0 1 2 3 console.log(arr[index]);// a b c d &#125; eg2:遍历对象123456789var obj=&#123; name:"Jin", age:11, [Symbol()]:123, &#125; for(let index in obj)&#123; console.log(index);//name age console.log(obj[index]);//Jin 11 &#125; eg3:遍历对象的顺序12345678910var obj=&#123; "49":"A", "a":"tt", "5":false, "1":"ss", &#125; for(let index in obj)&#123; console.log(index);//1 5 49 a console.log(obj[index])//ss false A tt &#125; for…in的要点：-不支持IE浏览器（IE9以下的）-遍历的顺序可能不是实际的内部顺序(先遍历出整数属性，按照升序)，然后其他属性按照创建时的顺序遍历出来-for in会遍历数组所有的可枚举属性，包括原型中存在的属性（object.prototype添加的属性）-for in一般用于遍历对象属性-for in无返回值-Symbol 作为属性名，该属性不会出现在for…in、循环中 for…of可遍历数组，Set,Map,类数组对象(eg:arguments,DOM NodeList对象，字符串)（ES6）不能遍历对象 eg1:遍历数组12345var arr=['a','b','c','d']; for(let key of arr)&#123; console.log(key);// a b c d console.log(arr[key]); //undefined undefined undefined undefined &#125; eg2:遍历对象123456789var obj=&#123; "49":"A", "a":"tt", "5":false, "1":"ss", &#125; for(let key of obj)&#123;//报错 console.log(index); &#125; eg3:for of与Object.keys()遍历对象12345678var obj=&#123; name:"Jin", age:11, &#125; for(let value of Object.keys(obj))&#123; console.log(value);//name age console.log(obj[value]);//Jin 11 &#125; eg4:for of与Object.keys()遍历数组索引 12345var arr=['a','b','c']; for(let value of Object.keys(arr))&#123; console.log(value);//0 1 2 console.log(arr[value]);// a b c &#125; eg4:for of与Object.entries()遍历索引和值123456var arr=['a','b','c']; for(let [index,value] of Object.entries(arr))&#123; console.log(index);//0 1 2 console.log(value);//a b c console.log(arr[index]);//a b c &#125; eg5:for of与Object.values()遍历属性值123456var arr=['a','b','c']; for(let [index,value] of Object.values(arr))&#123; console.log(index);//a b c console.log(value);//undefined undefined undefined console.log(arr[index]);//undefined undefined undefined &#125; for…of的要点： -for of其实遍历的是对象的Symbol.iterator属性，而对象没有该属性-不会遍历到对象属性和原型属性-如果要遍历对象，可与Object.keys()配合使用-配合Object.entries() 输出数组索引和元素值/对象的属性和属性值，但Symbol()属性会忽略-配合Object.values() 输出数组元素值/对象属性值，-一般用于遍历数组或者伪数组-无返回值-Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回 Iterator(遍历器)与for…of 遍历器（Iterator） 它是一种接口，为各种不同的数据结构（Array,Object,Set,Map）提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用一是为各种数据结构，提供访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 Iterator 的遍历过程 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。 原生具备 Iterator 接口的数据结构 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。 会默认调用 Iterator 接口场合 解构赋值 扩展运算符 yield* for…of Array.from() Map() Set() WeakMap() WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race()]]></content>
      <categories>
        <category>学习 - javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五环]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BA%94%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[描述：用5个div写成imgs/奥运五环 思路： (1)将五个div的边框设置为50%，成为圆形； 再使用绝对定位将元素设置到不同的位置，（注意：设置定位的元素的left/top/right/bottom默认值是auto,不是0） 再将每个元素下使用伪类添加一个相同属性的圆形 再利用z-index属性对元素中间夹实现五环（注意：定位的元素z-index才有效） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;circle&lt;/title&gt; &lt;style&gt; *&#123; margin: 0px; padding: 0px; &#125; .circle,.circle::after&#123; width: 200px; height:200px; border: 10px solid #0000ff; -webkit-border-radius: 50%; -moz-border-radius: 50%; border-radius: 50%; position: absolute; &#125; .circle::after&#123; content: ""; top:-10px; left:-10px; &#125; .circle1&#123; top:0px; left:0px; &#125; .circle1::after&#123; z-index: 1; border-bottom-color: transparent; &#125; .circle2&#123; border-color: #000000; top:0; left:230px; &#125; .circle2::after&#123; border-color: #000000; z-index: 1; border-left-color: transparent; &#125; .circle3&#123; border-color: #ff0000; top:0; left:460px; &#125; .circle3::after&#123; border-color: #ff0000; z-index: 1; border-left-color: transparent; &#125; .circle4&#123; border-color: #ffff00; left:110px; top: 110px; &#125; .circle4::after&#123; border-color: #ffff00; &#125; .circle5&#123; border-color: #00ff00; top: 110px; left:340px; &#125; .circle5::after&#123; border-color: #00ff00; z-index: 2; border-top-color: transparent; border-right-color: transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="circle circle1"&gt;&lt;/div&gt;&lt;div class="circle circle2"&gt;&lt;/div&gt;&lt;div class="circle circle3"&gt;&lt;/div&gt;&lt;div class="circle circle4"&gt;&lt;/div&gt;&lt;div class="circle circle5"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习 - CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[田字格]]></title>
    <url>%2F2019%2F05%2F04%2F%E7%94%B0%E5%AD%97%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[问题描述：写一个田字格，每一边的边距都为1px，当点击每一个小格子时，它周围的框颜色都发生变化解决方法： 将四个元素浮动在同一行，在清除第三个元素的浮动[clear：left; 清除浮动是影响自身，让自己在某个方向上没有之前浮动元素（清除之前的元素对自己的影响），所以第三个元素会掉下来，而第三，四个元素是浮动的所以会在一行；]//或者用位移） 再使用位移(transform:translate())或者定位（position:relative;）将多余的1px的边款合并； 最后当点击某个元素时，将z-index{定位的元素才能设z-index}设为》0的数， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;field&lt;/title&gt; &lt;style type="text/css"&gt; .field &#123; width: 100px; height: 100px; border: 1px solid #ff00ff; &#125; .field2&#123; transform: translate(101px,-102px); &#125; .field3&#123; transform: translateY(-103px); &#125; .field4&#123; transform: translate(101px,-205px); &#125; .field:hover&#123; position: relative; z-index: 1; border-color: aquamarine; &#125; /* .field &#123; width: 100px; height: 100px; border: 1px solid #ff00ff; float: left; &#125; .field2&#123; position: relative; left: -1px; &#125; .field3&#123; clear: both; position: relative; top: -1px; &#125; .field4&#123; position: relative; left: -1px; top: -1px; &#125; .field:hover&#123; border-color: greenyellow; position: relative; z-index: 1; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="field field1"&gt;&lt;/div&gt;&lt;div class="field field2"&gt;&lt;/div&gt;&lt;div class="field field3"&gt;&lt;/div&gt;&lt;div class="field field4"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习 - CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[太极图]]></title>
    <url>%2F2019%2F05%2F01%2F%E5%A4%AA%E6%9E%81%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;diagram&lt;/title&gt; &lt;style&gt; .diagram&#123; width: 400px; height: 400px; border: 1px solid #c0c0c0; margin: 100px auto; position: relative; border-radius: 200px; &#125; .diagram::before,.diagram::after&#123; content: ""; display: block; width: 200px; height: 400px; position: absolute; &#125; .diagram::before&#123; border-radius: 200px 0 0 200px; background-color: #fff; top:0px; left: 0px; &#125; .diagram::after&#123; border-radius: 0 200px 200px 0; background-color: #000; top:0px; right: 0px; &#125; .child&#123; width: 200px; height: 200px; border-radius: 100px; position: absolute; left: 100px; z-index: 1; &#125; .child1&#123; background-color: #000; top:0; &#125; .child2&#123; background-color:#fff; bottom:0px; &#125; .min&#123; width: 40px; height: 40px; background-color: #fff; position: absolute; top:80px; left: 80px; border-radius: 20px; &#125; .min2&#123; background-color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="diagram"&gt; &lt;div class="child child1"&gt; &lt;div class=" min min1"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="child child2"&gt; &lt;div class="min min2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习 - CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
