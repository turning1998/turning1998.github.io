<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP的结构]]></title>
    <url>%2F2019%2F05%2F24%2FHTTP%E7%9A%84%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[HTTP结构图 HTTP结构之请求篇 (1)组成http请求报文由三部分组成，分别是：请求行(请求头)、消息报头、请求正文。 请求头（请求行）以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。请求方法如下： 请求正文(实体主体)：一般不用(2)请求报文的例子12345GET /chn/yxsz/index.htm HTTP/1.1 /*请求行使用相对URL*/ Host:www.tsinghua.edu.cn /*此行为首部行的开始，给出主机的域名*/ Connection:close /*告诉服务器发送完请求的文档可释放连接*/ user-Agent:Mozilla/5.0 /*表明用户代理是使用Netscape浏览器*/ Accept-Language:cn /*表示用户希望优先得到中文版本的文档*/ (3)HTTP请求过程（从URL输入到页面展现发生什么？）a.域名解析(浏览器通过向 DNS 服务器发送域名，DNS 服务器查询(查询缓存)到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器) 查找浏览器缓存（DNS缓存） 查找操作系统缓存（如果浏览器缓存没有，浏览器会从hosts文件查找是否有DNS信息） 查找路由缓存 查找ISP缓存 查找ISP缓存ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推） b.发起TCP的3次握手（浏览器获得对应的ip地址后，浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。） c.建立TCP连接后发送HTTP请求报文 d.服务器处理请求，并返回HTTP响应报文 e.浏览器解析,渲染,并绘制到网页 根据 HTML 解析出 DOM 树 根据 CSS 解析生成 CSS 规则树 结合 DOM 树和 CSS 规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 f. 断开连接（TCP 四次挥手） HTTP结构之响应篇 (1)组成在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 状态行包括状态码，协议版本，状态码描述;(状态行格式如下：1HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述 a. 1XX（信息响应类，表示接受的请求正在处理） b. 2XX（处理成功类，表示请求已被成功接收、理解、接受） 200 OK //客户端请求成功 ，请求被成功处理，服务器会根据不同的请求方法返回结果：GET：请求的对应资源会作为响应返回。 HEAD：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body) POST：返回处理对应请求的结果。 204 No Content //该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。206 Partial Content //该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。客户端发起的请求，必须在请求头中包含Range字段。服务端响应报文中，必须包含由Content-Range指定范围的实体内容(entity-bodies )c. 3XX（重定向响应类，表示需要客户端需要进行附加操作） 301 Moved Permanently // 永久重定向 该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：HEAD：必须在响应头部Location字段中指明新的永久性的URI。 GET：除了有Location字段以外，还需要在响应体中附上永久性URI的超链接文本。 POST：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。 302 Found // 临时重定向，该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问 和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。303 See Other //临时重定向，该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请 求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。304 Not Modified //资源找到但是不符合请求条件 该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部。307 Temporary Redirect //临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)d. 4XX（客户端错误，请求有语法错误或请求无法实现） 400 Bad Request //错误请求 客表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。401 Unauthorized //请求未授权 该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含WWW-Authenticate以指明服务器需要哪种方式的认证。403 Forbidden //拒绝 该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应404 Not Found //未找到 该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。405 //方法禁用 禁用请求中指定的方法e. 5XX（服务端错误，服务器处理请求出错） 500 Internal Server Error //服务器内部错误 该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。501 //尚未实施 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 //错误网关 服务器作为网关或代理，从上游服务器收到无效响应。503 Service Unavailable //服务不可用 状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入Retry-After首部字段再返回给客户端。504 //网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求 HTTP结构之消息报文（HTTP协议头）篇(1)组成HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 普通报头 在普通报文头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。常用的普通报头a. Cache-Control:用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。b. Date:普通报头域表示消息产生的日期和时间c. Connection:普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 请求报头 请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头a.AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的源；Accept：text/html，表明客户端希望接受html文本 b.Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 c.Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip,deflate如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 d.Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 e.AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 f.Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html;浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号 g.User-AgentUser-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。请求报头举例： 12345678910GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF)(CRLF) 响应报头 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。常用的响应报头a. LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。 b.ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=&quot;Basic Auth Test!&quot; //可以看出服务器对请求资源采用的是基本验证机制。 实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。常用的实体报头a. Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipb. Content-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:dac.Content-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。d. Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：12Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312 e. Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。 f. ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(&quot;Expires&quot;,&quot;0&quot;); 参考文章 https://blog.csdn.net/gueter/article/details/1524447 https://github.com/forthealllight/blog/issues/19 https://www.cnblogs.com/fundebug/p/what-happens-from-url-to-webpage.html http://www.cnblogs.com/xianyulaodi/p/6547807.html https://my.oschina.net/snowing1990/blog/707165]]></content>
      <categories>
        <category>学习 - 计算机网络</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js:for ...of与 for... in]]></title>
    <url>%2F2019%2F05%2F24%2Ffor%20...of%E4%B8%8E%20for...%20in%2F</url>
    <content type="text"><![CDATA[for…in遍历对象的属性或数组索引（ES5） eg1:遍历数组12345var arr=['a','b','c','d']; for(let index in arr)&#123; console.log(index);// 0 1 2 3 console.log(arr[index]);// a b c d &#125; eg2:遍历对象123456789var obj=&#123; name:"Jin", age:11, [Symbol()]:123, &#125; for(let index in obj)&#123; console.log(index);//name age console.log(obj[index]);//Jin 11 &#125; eg3:遍历对象的顺序12345678910var obj=&#123; "49":"A", "a":"tt", "5":false, "1":"ss", &#125; for(let index in obj)&#123; console.log(index);//1 5 49 a console.log(obj[index])//ss false A tt &#125; for…in的要点：-不支持IE浏览器（IE9以下的）-遍历的顺序可能不是实际的内部顺序(先遍历出整数属性，按照升序)，然后其他属性按照创建时的顺序遍历出来-for in会遍历数组所有的可枚举属性，包括原型中存在的属性（object.prototype添加的属性）-for in一般用于遍历对象属性-for in无返回值-Symbol 作为属性名，该属性不会出现在for…in、循环中 for…of可遍历数组，Set,Map,类数组对象(eg:arguments,DOM NodeList对象，字符串)（ES6）不能遍历对象 eg1:遍历数组12345var arr=['a','b','c','d']; for(let key of arr)&#123; console.log(key);// a b c d console.log(arr[key]); //undefined undefined undefined undefined &#125; eg2:遍历对象123456789var obj=&#123; "49":"A", "a":"tt", "5":false, "1":"ss", &#125; for(let key of obj)&#123;//报错 console.log(index); &#125; eg3:for of与Object.keys()遍历对象12345678var obj=&#123; name:"Jin", age:11, &#125; for(let value of Object.keys(obj))&#123; console.log(value);//name age console.log(obj[value]);//Jin 11 &#125; eg4:for of与Object.keys()遍历数组索引 12345var arr=['a','b','c']; for(let value of Object.keys(arr))&#123; console.log(value);//0 1 2 console.log(arr[value]);// a b c &#125; eg4:for of与Object.entries()遍历索引和值123456var arr=['a','b','c']; for(let [index,value] of Object.entries(arr))&#123; console.log(index);//0 1 2 console.log(value);//a b c console.log(arr[index]);//a b c &#125; eg5:for of与Object.values()遍历属性值123456var arr=['a','b','c']; for(let [index,value] of Object.values(arr))&#123; console.log(index);//a b c console.log(value);//undefined undefined undefined console.log(arr[index]);//undefined undefined undefined &#125; for…of的要点： -for of其实遍历的是对象的Symbol.iterator属性，而对象没有该属性-不会遍历到对象属性和原型属性-如果要遍历对象，可与Object.keys()配合使用-配合Object.entries() 输出数组索引和元素值/对象的属性和属性值，但Symbol()属性会忽略-配合Object.values() 输出数组元素值/对象属性值，-一般用于遍历数组或者伪数组-无返回值-Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回 Iterator(遍历器)与for…of 遍历器（Iterator） 它是一种接口，为各种不同的数据结构（Array,Object,Set,Map）提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用一是为各种数据结构，提供访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 Iterator 的遍历过程 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。 原生具备 Iterator 接口的数据结构 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。 会默认调用 Iterator 接口场合 解构赋值 扩展运算符 yield* for…of Array.from() Map() Set() WeakMap() WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race()]]></content>
      <categories>
        <category>学习 - javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
